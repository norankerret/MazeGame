// ============================================================================
//   Ver  :| Author					:| Mod. Date :| Changes Made:
//   V1.1 :| Alexandra Du			:| 06/01/2016:| Added Verilog file
// ============================================================================


//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

`define ENABLE_ADC_CLOCK
`define ENABLE_CLOCK1
`define ENABLE_CLOCK2
`define ENABLE_SDRAM
`define ENABLE_HEX0
`define ENABLE_HEX1
`define ENABLE_HEX2
`define ENABLE_HEX3
`define ENABLE_HEX4
`define ENABLE_HEX5
`define ENABLE_KEY
`define ENABLE_LED
`define ENABLE_SW
`define ENABLE_VGA
`define ENABLE_ACCELEROMETER
`define ENABLE_ARDUINO
`define ENABLE_GPIO

`include "user_defined_types.sv"

module DE10_LITE_Golden_Top(

	//////////// ADC CLOCK: 3.3-V LVTTL //////////
`ifdef ENABLE_ADC_CLOCK
	input 		          		ADC_CLK_10,
`endif
	//////////// CLOCK 1: 3.3-V LVTTL //////////
`ifdef ENABLE_CLOCK1
	input 		          		MAX10_CLK1_50,
`endif
	//////////// CLOCK 2: 3.3-V LVTTL //////////
`ifdef ENABLE_CLOCK2
	input 		          		MAX10_CLK2_50,
`endif

	//////////// SDRAM: 3.3-V LVTTL //////////
`ifdef ENABLE_SDRAM
	output		    [12:0]		DRAM_ADDR,
	output		     [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [15:0]		DRAM_DQ,
	output		          		DRAM_LDQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_UDQM,
	output		          		DRAM_WE_N,
`endif

	//////////// SEG7: 3.3-V LVTTL //////////
`ifdef ENABLE_HEX0
	output		     [7:0]		HEX0,
`endif
`ifdef ENABLE_HEX1
	output		     [7:0]		HEX1,
`endif
`ifdef ENABLE_HEX2
	output		     [7:0]		HEX2,
`endif
`ifdef ENABLE_HEX3
	output		     [7:0]		HEX3,
`endif
`ifdef ENABLE_HEX4
	output		     [7:0]		HEX4,
`endif
`ifdef ENABLE_HEX5
	output		     [7:0]		HEX5,
`endif

	//////////// KEY: 3.3 V SCHMITT TRIGGER //////////
`ifdef ENABLE_KEY
	input 		     [1:0]		KEY,
`endif

	//////////// LED: 3.3-V LVTTL //////////
`ifdef ENABLE_LED
	output		     [9:0]		LEDR,
`endif

	//////////// SW: 3.3-V LVTTL //////////
`ifdef ENABLE_SW
	input 		     [9:0]		SW,
`endif

	//////////// VGA: 3.3-V LVTTL //////////
`ifdef ENABLE_VGA
	output		     [3:0]		VGA_B,
	output		     [3:0]		VGA_G,
	output		          		VGA_HS,
	output		     [3:0]		VGA_R,
	output		          		VGA_VS,
`endif

	//////////// Accelerometer: 3.3-V LVTTL //////////
`ifdef ENABLE_ACCELEROMETER
	output		          		GSENSOR_CS_N,
	input 		     [2:1]		GSENSOR_INT,
	output		          		GSENSOR_SCLK,
	inout 		          		GSENSOR_SDI,
	inout 		          		GSENSOR_SDO,
`endif

	//////////// Arduino: 3.3-V LVTTL //////////
`ifdef ENABLE_ARDUINO
	inout 		    [15:0]		ARDUINO_IO,
	inout 		          		ARDUINO_RESET_N,
`endif

	//////////// GPIO, GPIO connect to GPIO Default: 3.3-V LVTTL //////////
`ifdef ENABLE_GPIO
	inout 		    [35:0]		GPIO
`endif
);


//=========================================================================================================//
//  logic/logic declarations
//=========================================================================================================//

logic pixel_clk;

logic [31:0] col;    // Column value from vga_controller
logic [31:0] row;    // Row value from vga_controller

logic [31:0] currentBallRow = 240;
logic [31:0] currentBallCol = 320;
parameter [31:0] ballRadius = 8;

logic data_update;
logic [15:0] data_x;
logic [15:0] data_y;

logic [2:0] horizontal;
logic [2:0] vertical;

logic [7:0] ones;
logic [7:0] tens;
logic [7:0] countdown;
logic [7:0] delay;
logic [7:0] value;

logic [7:0] scoreones;
logic [7:0] scoretens;
logic [7:0] score;

logic [7:0] highscoreones;
logic [7:0] highscoretens;
logic [7:0] highscore;

logic win = 0;
logic lose = 0;
logic [9:0] ledr = 10'b0000000000;
assign LEDR = ledr;

logic change;
integer confetti_pause;
integer pause = 0;

localparam SPI_CLK_FREQ  = 200;
localparam UPDATE_FREQ   = 1;

logic reset_n;
logic clk, spi_clk, spi_clk_out;

barrier_struct barrier_array [100:0];
endzone_struct endzone_array [3:0];
confetti_struct confetti_array [100:0];
win_struct win_array [50:0];
lose_struct lose_array [90:0];

//=========================================================================================================//
// Instantations
//=========================================================================================================//

//===== Phase-locked Loop (PLL) instantiation. Code was copied from a module
//      produced by Quartus' IP Catalog tool.

pll ip_inst (
   .inclk0 ( MAX10_CLK1_50 ),
   .c0 ( clk ),                 // 25 MHz, phase   0 degrees
   .c1 ( spi_clk ),             //  2 MHz, phase   0 degrees
   .c2 ( spi_clk_out )          //  2 MHz, phase 270 degrees
   );

//===== Instantiation of the spi_control module which provides the logic to 
//      interface to the accelerometer.

spi_control #(     // parameters
      .SPI_CLK_FREQ   (SPI_CLK_FREQ),
      .UPDATE_FREQ    (UPDATE_FREQ))
   spi_ctrl (      // port connections
      .reset_n    (reset_n),
      .clk        (clk),
      .spi_clk    (spi_clk),
      .spi_clk_out(spi_clk_out),
      .data_update(data_update),
      .data_x     (data_x),
      .data_y     (data_y),
      .SPI_SDI    (GSENSOR_SDI),
      .SPI_SDO    (GSENSOR_SDO),
      .SPI_CSN    (GSENSOR_CS_N),
      .SPI_CLK    (GSENSOR_SCLK),
      .interrupt  (GSENSOR_INT)
   );
	
pll pll_inst(.inclk0(MAX10_CLK1_50), .c0(pixel_clk));
vga_controller(pixel_clk, KEY[0], VGA_HS, VGA_VS, disp_ena, col, row);

barrier_factory(SW[9], barrier_array);
makebarrier b(row, col, barrier_array, isbarrier);

endzone_factory(SW[9], endzone_array);
makeendzone e(row, col, endzone_array, isendzone);

screen_display one(KEY[0], SW[9], row, col, pixel_clk, change, currentBallRow, currentBallCol, countdown, isdelay, isbarrier, isendzone, iswin, win, islose, lose, isconfetti, VGA_R[3:0],  VGA_G[3:0], VGA_B[3:0], collision, touchdown);

clockdivider(MAX10_CLK1_50, cout);
timer(cout, KEY[0], KEY[1], win, LEDR[9:0], countdown, delay);

seconds(value, ones, tens, HEX0, HEX1);

scoreboard(score, highscore, scoreones, scoretens, highscoreones, highscoretnes, HEX5, HEX4, HEX3, HEX2);

win_factory(win_array);
makewin w(row, col, win_array, iswin);

lose_factory(lose_array);
makelose l(row, col, lose_array, islose);

confetti_factory(confetti_array);
makeconfetti c(row, col, confetti_array, isconfetti);

//=========================================================================================================//
//  Structural coding
//=========================================================================================================//

assign reset_n = SW[0];

initial begin
	highscore = 0;
end

always_ff @(posedge cout) begin

	if (delay > 0) begin // display 3 second delay
		value = delay;
	end
	else if (delay == 0) begin // display 30 second countdown
		value = countdown;
	end
	
	if (countdown < 10) begin // led conditions
		ledr[9:0] <= ~ledr[9:0];
	end
	
	if (win) begin
		ledr[9:0] <= 10'b1111111111;
	end
	
	if (lose) begin
		ledr[9:0] <= 10'b0000000000;
	end
	
	if (!KEY[0]) begin
		ledr[9:0] <= 10'b0000000000;
	end
end

always_ff @(posedge pixel_clk) begin

// results

	if (countdown == 0) begin
		if (score >= 3) begin // win conditions
			win = 1;
		end
	end
	
	if (countdown == 0) begin
		if (score < 3) begin // lose conditions
			lose = 1;
		end
	end
	
	if (win) begin // if win
		if (score > highscore) begin
			highscore = score;
			if (confetti_pause < 100000) begin // change confetti colour
				change = 0;
				confetti_pause = confetti_pause + 1;
			end
			else begin
				change = 1;
				confetti_pause = 0;
			end
		end
	end

	if (lose) begin // if lose
		score = 0;
	end

//=========================================================================================================//

// play

	if (!KEY[0]) begin // reset all values to initial position/ values
		currentBallRow = 240;
		currentBallCol = 320;
		score = 0;
		win = 0;
		lose = 0;
	end

	else begin		
				
		if (collision) begin // if collision
			case (horizontal) 
				1: currentBallCol = currentBallCol - 10; // bounce ball left to avoid crossing barrier
				2: currentBallCol = currentBallCol + 10; // bounce ball right to avoid crossing barrier
			endcase
			case (vertical)
				1: currentBallRow = currentBallRow + 10; // bounce ball down to avoid crossing barrier
				2: currentBallRow = currentBallRow - 10; // bounce ball up to avoid crossing barrier
			endcase
			horizontal = 0;
			vertical = 0;
		end
		
		else if (touchdown) begin // if touchdown
			currentBallRow = 240; // reset ball to middle
			currentBallCol = 320; // reset ball to middle
			score = score + 1; // add 1 point to score
		end

		else begin // if neither touchdown nor collision
		
			if (countdown <= 29) begin
		
				if (data_x[12]) begin // check the status of data_x sign bit
					horizontal = 1; // set horizontal direction to right if sign bit is positive
				end
				else if (!(data_x[12])) begin // check the status of data_x sign bit
					horizontal = 2; // set horizontal direction to left is sign bit is negative
				end
				if (data_y[12]) begin // check the status of data_y sign bit
					vertical = 1; // set vertical direction to up if sign bit is positive
				end
				else if (!(data_y[12])) begin // check the status of data_y sign bit
					vertical = 2; // set vertical direction to down if sign bit is negative
				end
				
				if (pause < 400000) begin // dont move ball until 400 000 clock cycles have passed
					currentBallRow = currentBallRow;
					currentBallCol = currentBallCol;
					pause = pause + 1;
				end
				else begin
					if (horizontal == 1) begin 
						currentBallCol = currentBallCol + 1; // move ball right
						if (currentBallCol >= 630) begin // if ball reaches right side of screen
							currentBallCol = (0 + (ballRadius + 5)); // wrap ball around to left side
						end
					end
					else if (horizontal == 2) begin
						currentBallCol = currentBallCol - 1; // move ball left
						if (currentBallCol <= 5) begin // if ball reaches left side of screen
							currentBallCol = (640 - (ballRadius + 5)); // wrap ball around to right side
						end
					end

					if (vertical == 1) begin
						currentBallRow = currentBallRow - 1; // move ball up
						if (currentBallRow <= 5) begin // if ball reaches top of screen
							currentBallRow = (480 - (ballRadius + 5)); // wrap ball around to bottom
						end						
					end
					else if (vertical == 2) begin
						currentBallRow = currentBallRow + 1; // move ball down
						if (currentBallRow >= 470) begin // if ball reaches bottom of screen
							currentBallRow = (0 + (ballRadius + 5)); // wrap ball around to top
						end
					end
					
					pause = 0; // reset pause
				end
			end
		end
	end
end


//=========================================================================================================//
//=========================================================================================================//

endmodule
